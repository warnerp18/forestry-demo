import utils from './utils';

const ROOT_SELECTOR = '.js-dynamic-number-input';
const INPUT_SELECTOR = '.js-input';
const SUBMIT_SELECTOR = '.js-submit';
const CLEAN_CLASS = 'is-clean';
const ERROR_CLASS = 'is-error';
const ENTER = 'Enter';

export const COMPONENT_SELECTOR = ROOT_SELECTOR;
export default function createDynamicNumberInput(element) {
  const view = {
    root: element,
    inputField: element.querySelector(INPUT_SELECTOR),
    submitButton: element.querySelectorAll(SUBMIT_SELECTOR),
  };

  const model = createModel(element, {
    minValue: element.getAttribute('data-min-value'),
    maxValue: element.getAttribute('data-max-value'),
    value: element.getAttribute('data-default'),
  });

  utils.addEventListener(view.inputField, 'input', () => {
    const numberValue = fromCommaSeparated(view.inputField.value);
    model.setValue(numberValue);
  });

  utils.addEventListener(element, 'modelupdated', () => render(model, view));
  utils.addEventListener(view.inputField, 'blur',
    unless(model.isValid, () => showErrorMessage(view)));
  utils.addEventListener(view.inputField, 'keydown', ifEnter(onSubmit(model, view)));

  utils.forEach(view.submitButton,
    (item) => {
      utils.addEventListener(item, 'click', onSubmit(model, view));
    });

  initialize(view);

  return model;
}

function createModel(emitter, initialValues) {
  const model = {
    minValue: parseInt(initialValues.minValue, 10),
    maxValue: parseInt(initialValues.maxValue, 10),
    value: parseInt(initialValues.value, 10),
    cursorPosition: 0,
  };

  return {
    getValue() {
      return model.value;
    },
    getCursorPosition() {
      return model.cursorPosition;
    },
    setCursorPosition(value) {
      model.cursorPosition = value;
    },
    setValue(value) {
      model.value = value;
      emitter.dispatchEvent(modelUpdated());
    },
    isValid() {
      return (model.minValue <= model.value) && (model.value <= model.maxValue);
    },
  };
}

function render(model, view) {
  const formattedValue = toCommaSeparated(model.getValue());
  storeCursorPosition(model, view);
  view.inputField.value = formattedValue;
  view.inputField.size = formattedValue.length;
  restoreCursorPosition(model, view);

  hideErrorMessage(view);
  showSubmitButton(view);
}

function onSubmit(model, view) {
  return (event) => {
    if (model.isValid()) {
      hideSubmitButton(view);
    } else {
      event.preventDefault();
      showErrorMessage(view);
    }
  };
}

function initialize(view) {
  view.root.dispatchEvent(modelUpdated());
  hideSubmitButton(view);
}

function modelUpdated() {
  return new CustomEvent('modelupdated');
}

function fromCommaSeparated(string) {
  return Number(string.replace(/\D/g, ''));
}

function toCommaSeparated(number) {
  return number.toLocaleString().split('.')[0];
}

function storeCursorPosition(model, view) {
  model.setCursorPosition(view.inputField.value.length - view.inputField.selectionStart);
}

function restoreCursorPosition(model, view) {
  const cursorPosition = view.inputField.value.length - model.getCursorPosition();
  view.inputField.setSelectionRange(cursorPosition, cursorPosition);
}

function showSubmitButton(view) {
  utils.removeClass(view.root, CLEAN_CLASS);
}

function hideSubmitButton(view) {
  utils.addClass(view.root, CLEAN_CLASS);
}

function showErrorMessage(view) {
  utils.addClass(view.root, ERROR_CLASS);
}

function hideErrorMessage(view) {
  utils.removeClass(view.root, ERROR_CLASS);
}

function ifEnter(fn) {
  return (event) => {
    if (event.key === ENTER) {
      fn(event);
    }
  };
}

function unless(cond, then) {
  return () => {
    if (!cond()) {
      then();
    }
  };
}
