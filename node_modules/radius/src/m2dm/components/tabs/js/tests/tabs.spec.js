import tabsComponent from '..';

describe('tabs component', () => {
  const fixture = `
  <div id="test-tabs-1" class="tabs" data-tabs>
    <ol class="tablist" data-tablist>
      <li class="tablist__item">
        <a data-tablist-item class="tablist__link" href="#tab1">Tab 1</a>
      </li>
      <li class="tablist__item">
        <a data-tablist-item class="tablist__link" href="#tab2">Tab 2</a>
      </li>
    </ol>

    <div class="tabpanels">
      <div id="tab1" data-tabpanel class="tabpanels__item">
        <div class="placeholder-component">1</div>
      </div>
      <div id="tab2" data-tabpanel class="tabpanels__item">
        <div class="placeholder-component">2</div>
      </div>
    </div>
  </div>
  <div id="test-tabs-2" class="tabs" data-tabs>
    <ol class="tablist" data-tablist>
      <li class="tablist__item">
        <a data-tablist-item class="tablist__link" href="#tab4">Tab 4</a>
      </li>
      <li class="tablist__item">
        <a data-tablist-item class="tablist__link" href="#tab5">Tab 5</a>
      </li>
    </ol>

    <div class="tabpanels">
      <div id="tab4" data-tabpanel class="tabpanels__item">
        <div class="placeholder-component">1</div>
      </div>
      <div id="tab5" data-tabpanel class="tabpanels__item">
        <div class="placeholder-component">2</div>
      </div>
    </div>
  </div>
  `;

  beforeEach(() => {
    document.body.innerHTML = fixture;
  });

  it('module is a function', () => {
    expect(tabsComponent).toEqual(jasmine.any(Function));
  });

  describe('when the function is called', () => {
    let component1;
    let component2;

    beforeEach(() => {
      const component1root = document.getElementById('test-tabs-1');
      const component2root = document.getElementById('test-tabs-2');
      window.onerror = jasmine.createSpy('Global error handler');

      tabsComponent();

      component1 = {
        root: component1root,
        tablist: component1root.querySelector('[data-tablist]'),
        tabs: Array.from(component1root.querySelectorAll('[data-tablist-item]')),
        panels: Array.from(component1root.querySelectorAll('[data-tabpanel]')),
      };

      component2 = {
        root: component2root,
        tabs: component2root.querySelectorAll('[data-tablist-item]'),
        panels: component2root.querySelectorAll('[data-tabpanel]'),
      };
    });

    it('adds the has-js class to all root elements', () => {
      expect(component1.root).toHaveClass('has-js');
      expect(component2.root).toHaveClass('has-js');
    });

    it('adds the is-selected class to the first tab', () => {
      expect(component1.tabs[0]).toHaveClass('is-selected');
      expect(component2.tabs[0]).toHaveClass('is-selected');
    });

    it('adds the aria-selected attribute to the first tab', () => {
      expect(component1.tabs[0].getAttribute('aria-selected')).toBe('true');
      expect(component2.tabs[0].getAttribute('aria-selected')).toBe('true');
    });

    it('add the is-hidden class to all but the first tabpanel', () => {
      expect(component1.panels[0]).not.toHaveClass('is-hidden');
      expect(component1.panels[1]).toHaveClass('is-hidden');
      expect(component2.panels[0]).not.toHaveClass('is-hidden');
      expect(component2.panels[1]).toHaveClass('is-hidden');
    });

    it('adds the aria-hidden attribute to all but the first tabpanel', () => {
      expect(component1.panels[0].getAttribute('aria-hidden')).toBe(null);
      expect(component1.panels[1].getAttribute('aria-hidden')).toBe('true');
    });

    it('adds tablist role to the tablist', () => {
      expect(component1.tablist.getAttribute('role')).toEqual('tablist');
    });

    it('adds presentation role to the direct children of tablist', () => {
      const result = Array.from(component1.tablist.children)
        .map(el => el.getAttribute('role'))
        .every(role => role === 'presentation');
      expect(result).toEqual(true);
    });

    it('adds tab role to the tabs', () => {
      expect(component1.tabs.every(el => el.getAttribute('role') === 'tab')).toBe(true);
    });

    it('adds the tabpanel role to each panel', () => {
      expect(component1.panels.every(el => el.getAttribute('role') === 'tabpanel')).toBe(true);
    });

    it('uses the href as the value for aria controls', () => {
      const result = component1.tabs.map(el => el.getAttribute('aria-controls'));
      expect(result).toEqual([
        'tab1',
        'tab2',
      ]);
    });

    it('makes all panels focusable', () => {
      const result = component1.panels
        .map(p => p.getAttribute('tabindex'))
        .every(t => t === '0');

      expect(result).toEqual(true);
    });

    describe('when a tablist is clicked', () => {
      let tablist;
      let globalErrorHandler;

      beforeEach(() => {
        tablist = document.querySelector('[data-tablist]');
        globalErrorHandler = jasmine.createSpy('global error handler');
        window.onerror = globalErrorHandler;
        triggerClickEvent(tablist);
      });

      it('does not throw an error', () => {
        expect(globalErrorHandler).not.toHaveBeenCalled();
      });
    });

    describe('when a tab is clicked', () => {
      let evt;
      beforeEach(() => {
        evt = triggerClickEvent(component1.tabs[1]);
      });

      it('is-selected is removed from the current tab', () => {
        expect(component1.tabs[0]).not.toHaveClass('is-selected');
      });

      it('removes aria-selected from the current tab', () => {
        expect(component1.tabs[0].getAttribute('aria-selected')).toBe(null);
      });

      it('does not affect the other component', () => {
        expect(component2.tabs[0]).toHaveClass('is-selected');
        expect(component2.tabs[1]).not.toHaveClass('is-selected');
      });

      it('is-selected is added to the clicked tab', () => {
        expect(component1.tabs[1]).toHaveClass('is-selected');
      });

      it('tabindex is set to -1 for current tab', () => {
        expect(component1.tabs[0].getAttribute('tabindex')).toEqual('-1');
      });

      it('tabindex is set to 0 for clicked tab', () => {
        expect(component1.tabs[1].getAttribute('tabindex')).toEqual('0');
      });

      it('adds is-hidden class to the current panel', () => {
        expect(component1.panels[0]).toHaveClass('is-hidden');
      });

      it('removes is-hidden from the clicked panel', () => {
        expect(component1.panels[1]).not.toHaveClass('is-hidden');
      });

      it('prevents default', () => {
        expect(evt.preventDefault).toHaveBeenCalled();
      });
    });

    describe('when the left arrow is pressed', () => {
      describe('on the left most tab', () => {
        beforeEach(() => {
          triggerKeyDown(component1.tabs[0], 37);
        });

        it('does not blow up', () => {
          expect(window.onerror).not.toHaveBeenCalled();
        });
      });

      describe('on the right most tab', () => {
        beforeEach(() => {
          triggerClickEvent(component1.tabs[1]);
          triggerKeyDown(component1.tabs[1], 37);
        });

        it('selects the previous tab', () => {
          expect(component1.tabs[0]).toHaveClass('is-selected');
        });

        it('sets focus to the previous tab', () => {
          expect(component1.tabs[0].id).toBe(document.activeElement.id);
        });
      });
    });

    describe('when the right arrow is pressed', () => {
      describe('on the left most tab', () => {
        beforeEach(() => {
          triggerKeyDown(component1.tabs[0], 39);
        });

        it('selects the next tab', () => {
          expect(component1.tabs[1]).toHaveClass('is-selected');
        });

        it('sets focus to the previous tab', () => {
          expect(component1.tabs[1]).toBe(document.activeElement);
        });

        it('selects the corresponding panel', () => {
          expect(component1.panels[1]).not.toHaveClass('is-hidden');
        });
      });

      describe('on the right most tab', () => {
        beforeEach(() => {
          triggerClickEvent(component1.tabs[1], 39);
        });

        it('does not blow up', () => {
          expect(window.onerror).not.toHaveBeenCalled();
        });
      });
    });

    describe('when the tab key is pressed', () => {
      beforeEach(() => {
        triggerKeyDown(component1.tabs[0], 9);
      });

      it('focuses the tab', () => {
        expect(component1.panels[0]).toBe(document.activeElement);
      });

      it('sets the background to not transparent on all the tabs', () => {
        expect(component1.tabs[0]).not.toHaveClass('tablist__item--transparent');
      });
    });

    describe('when any button is pressed', () => {
      let evt;

      beforeEach(() => {
        evt = triggerKeyDown(component1.tabs[1], 1);
      });

      it('does not interfere', () => {
        expect(evt.preventDefault).not.toHaveBeenCalled();
      });
    });

    describe('when shift+tab buttons are pressed', () => {
      let evt;

      beforeEach(() => {
        evt = triggerKeyDown(component1.tabs[1], 9, 'Shift');
      });

      it('does not interfere', () => {
        expect(evt.preventDefault).not.toHaveBeenCalled();
      });
    });
  });
});

function triggerClickEvent(element) {
  const event = new Event('click', {
    bubbles: true,
  });
  spyOn(event, 'preventDefault');

  element.dispatchEvent(event);
  return event;
}

function triggerKeyDown(element, keyCode, modifier) {
  const event = new Event('keydown', {
    bubbles: true,
  });
  event.keyCode = keyCode;
  spyOn(event, 'preventDefault');
  // I wasn't able to construct a KeyboardEvent so I am using a regular Event instead,
  // which doesn't have the getModifierState function
  event.getModifierState = jasmine.createSpy('getModifierState')
    .and.callFake(key => key === modifier);

  element.dispatchEvent(event);
  return event;
}
